//! We use `datafrog` to implement the actual inference.

use crate::full_inference::constraint::Constraint;
use crate::full_inference::constraint::ConstraintAt;
use crate::full_inference::perm::Perm;
use crate::full_inference::perm::PermData;
use crate::full_inference::perm::PermVar;
use crate::full_inference::FullInferenceTables;
use datafrog::Iteration;
use datafrog::Relation;
use lark_collections::FxIndexMap;
use lark_collections::FxIndexSet;
use lark_intern::Intern;
use lark_intern::Untern;
use lark_ty::PermKind;

/*

## Basic permission inference

The role of "basic permission inference" is to decide, for each
permission variable `P`, whether it is "share" or "borrow" or
"owned".

For each permission variable P, we have two relations we are computing:

```
borrow(P)
owned(P)
```

The rules are derived from the base constraints generated by the
program. We expect the following input relations:

```
perm_less0(Pa, Pb).          // input
perm_condition0(Pc, Pa, Pb). // input
```

Our rules are then:

```
perm_less(Pa, Pb) :- perm_less0(Pa, Pb).

perm_less(Pa, Pb) :- perm_condition0(Pc, Pa, Pb), borrow(Pc).

borrow(Pb) :-
  perm_less(Pa, Pb),
  borrow(Pa).

owned(Pb) :-
  perm_less(Pa, Pb),
  owned(Pa).
```

## "Ownership checking"

Assume an input that tells where each access occurs and with which
permission:

```
access(Loan, Perm, Node). // input
```

We call that access a **move** if the permission requires "own":

```
move(Loan, Node) :-
  access(Loan, Perm, Node),
  own(Perm).
```

XXX this seems wrong, we need to permit re-assignment etc. Do we just
want to flow initialization?

We say that there is a "future move" at a node `N` if control-flow may
reach some (strict) successor `M` that moves:

```
future_move(Loan, Node) :- successor(Node, Node1), move(Loan, Node1).

successor(Node, Node1) :- cfg_edge(Node, Node).
successor(Node, Node2) :- successor(Node, Node1), cfg_edge(Node1, Node2).
```

It is an error to have a move and a future-move at the same point
if the two loans "intersect":

```
error(Node) :-
  move(Loan, Node),
  future_move(Loan1, Node),
  intersect(Loan, Loan1).

intersect(Loan, Loan1). // input: two loans access overlapping places
```

## "Loan checking"

The role of "loan checking" is to check that, when something is loaned
(shared or borrowed), we respect the terms of that loan. Specifically,
shared things may not be mutated, and borrowed things may not be
accessed -- until the end of the loan.

```
use(Variable, Node). // input
define(Variable, Node). // input
```

We can then define which variables are **live** in the usual fashion:

```
variableLive(Variable, Node) :- use(Variable, Node).
variableLive(Variable, Node) :- cfg_edge(Node, Node1), live(Variable, Node1), !define(Variable, Node).
```

We need to know which permissions are part of a variable's type:

```
requires(Variable, Perm). // input
```

We can say that a permission is "live" at some point if a variable is
live that has that permission in its type:

```
permLive(Perm, Node) :- variableLive(Variable, Node), requires(Variable, Perm).
```

As with polonius, we want to track which loans are live -- this
basically requires us to figure out, for each live permissions, the
things it derives from.

*/

crate fn inference(
    db: &impl AsRef<FullInferenceTables>,
    constraints: &FxIndexSet<ConstraintAt>,
) -> FxIndexMap<PermVar, PermKind> {
    let mut iteration = Iteration::new();

    let perm_less = iteration.variable::<(Perm, Perm)>("perm_less");
    perm_less.insert(Relation::from(constraints.iter().flat_map(|c| {
        let (p_a, p_b) = match c.constraint {
            Constraint::PermEquateConditionally { .. } => (None, None),
            Constraint::PermEquate { a, b } => (Some((a, b)), Some((b, a))),
            Constraint::PermPermits { a, b } => (Some((b, a)), None),
        };

        p_a.into_iter().chain(p_b)
    })));

    let perm_condition0 = iteration.variable::<(Perm, (Perm, Perm))>("perm_condition");
    perm_condition0.insert(Relation::from(constraints.iter().flat_map(|c| {
        let (p_a, p_b) = match c.constraint {
            Constraint::PermEquateConditionally { condition, a, b } => {
                (Some((condition, (a, b))), Some((condition, (b, a))))
            }
            Constraint::PermEquate { .. } => (None, None),
            Constraint::PermPermits { .. } => (None, None),
        };

        p_a.into_iter().chain(p_b)
    })));

    let perm_borrow: Perm = PermKind::Borrow.intern(db);
    let perm_own: Perm = PermKind::Own.intern(db);

    let borrow = iteration.variable::<(Perm, ())>("borrow");
    borrow.insert(Relation::from(
        std::iter::once((perm_borrow, ())).chain(std::iter::once((perm_own, ()))),
    ));

    let owned = iteration.variable::<(Perm, ())>("borrow");
    owned.insert(Relation::from(std::iter::once((perm_own, ()))));

    while iteration.changed() {
        // perm_less(Pb) :- perm_condition(Pc, Pa, Pb), borrow(Pc).
        perm_less.from_join(&perm_condition0, &borrow, |&_p_c, &(p_a, p_b), &()| {
            (p_a, p_b)
        });

        // borrow(Pb) :- perm_less(Pa, Pb), borrow(Pa).
        borrow.from_join(&perm_less, &borrow, |&_p_a, &p_b, &()| (p_b, ()));

        // owned(Pb) :- perm_less(Pa, Pb), owned(Pa).
        owned.from_join(&perm_less, &owned, |&_p_a, &p_b, &()| (p_b, ()));
    }

    let borrow = borrow.complete();
    let owned = owned.complete();

    let mut set: FxIndexMap<PermVar, PermKind> = FxIndexMap::default();
    set.extend(
        borrow
            .elements
            .iter()
            .filter_map(|&(v, ())| match v.untern(db) {
                PermData::Inferred(v) => Some((v, PermKind::Borrow)),
                PermData::Known(_) | PermData::Placeholder(_) => None,
            }),
    );
    set.extend(
        owned
            .elements
            .iter()
            .filter_map(|&(v, ())| match v.untern(db) {
                PermData::Inferred(v) => Some((v, PermKind::Own)),
                PermData::Known(_) | PermData::Placeholder(_) => None,
            }),
    );
    set
}
